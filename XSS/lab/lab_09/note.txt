XSS - Reflected DOM XSS

End Goal: create an injection that calls the alert() function.

Analystic
---------
Trong lab này, không còn có tập lệnh JS nằm trong trang mà nằm bên ngoài trang là searchResults.js. Ta có thể mở file này trong phần source hoặc network. JS này không bị làm xáo trộn (mã hóa), nó ở định dạng dễ đọc. Trước hết nó có 1 hàm search và được truyền 1 tham số đường dẫn. Nếu quay lại trang mã web trình kiểm tra DOM chỉ ra rằng JS đang thực sự gọi hàm này và truyền vào search-results. Điểm mấu chốt ở đây là trang đang gọi hàm search nên điều này sẽ kích hoạt JS của chúng ta.
Trong tệp JS đầu tiên ta thấy 1 biến mới được tạo là xhr được gán cho 1 đối tượng JS tích hợp gọi là XMLHttpRequest. Giờ không còn nhiều trong JS hiện tại vì chúng được thay thế trong nhiều trường hợp bằng các lời hứa nhưng chức năng vẫn giống nhau, cho phép ta thực hiện yêu cầu không đồng bộ tới tài nguyên bên ngoài và điều này đôi khi được gọi là ajax, viết tắt của JS và XML không đồng bộ. Trớ trêu là ngay cả khi sử dụng Ajax, nó thường không liên quan đến XML mà thường liên quan đến JSON. Nhưng vì bất kì lí do gì, nó vẫn được gọi là XML trước khi JSON trở nên rất phổ biến. XML thường được sử dụng để liên lạc giữa các tiến trình trên 1 ứng dụng web trong khi hầu hết các trường hợp chúng ta sử dụng JSON nhưng vẫn có 1 số XML được sử dụng trên các trang web, nên đối tượng xhr được tạo, sau đó chúng ta liên kết 1 hàm tới 1 trình xử lý sự kiện (xhr.onreadystatechange) để có trình xử lý sự kiện này khi trạng thái sẵn sàng. Ý tưởng là khi đối tượng xhr có thuộc tính trạng thái sẵn sàng này (readyState = 4) thứ cho biết trạng thái của yêu cầu và thông tin quan trọng mà chúng ta cần là trạng thái sẵn sàng 4 có nghĩa là yêu cầu đã được hoàn thành, nên mỗi khi trạng thái sẵn sàng thay đổi, chức năng này sẽ được kích hoạt, nó kiểm tra xem trạng thái sẵn sàng có phải là 4 hay không và http status có bằng 200 không. Nếu cả 2 đkiện thỏa mãn nghĩa là HTTP request đã thành công và chúng ta có thể truy cập dữ liệu phản hồi bằng cách sử dụng this.responseText. Sau đó chúng ta cần sử dụng phương thức .open, cung cấp 1 số tham số như path, thứ đã được cung cấp thông qua tham số path từ tài liệu HTML document.location.search (nó lấy bất cứ gì sau truy vấn). Cuối cùng gọi phương thức send() sẽ gửi yêu cầu HTTP. Hãy giả vờ ta gửi HTTP request với thông tin tìm kiếm, chúng ta hiện đã nhận được phản hồi thì JS đang làm gì với phản hồi, nó gọi một eval() chuyền vào 'var searchResultsObj = ' như 1 phần của của chuỗi, sau đó nối chuỗi đó với this.responseText. Cuối cùng nó lấy đối tượng vừa tạo chuyển nó sang 1 hàm thứ 2 được gọi là displaySearchResults(searchResultsObj). Giờ ta sẽ tập trung vào dòng mã eval(), có thể thấy rằng 1 chuỗi được truyền vào hàm eval, vậy hàm eval trong JS là gì?, hàm eval đánh giá mã JS được biểu thị dưới dạng 1 chuỗi và trả về giá trị hoàn thành của nó, sau đó lưu ý rằng cảnh báo việc thực thi JS từ 1 chuỗi là rủi ro bảo mật lớn, kẻ xấu có thể dễ dàng chạy mã tùy ý khi bạn sử dụng eval(), nên không được sử dụng eval(). 
Quay trở lại với lab, refesh để gửi cùng 1 cụm từ tìm kiếm vì nó có trong chuỗi truy vấn (search=tmt), giờ theo dõi để biết rằng hàm tìm kiếm đó được gọi do đối tượng xhr được tạo thì chúng ta mong đợi 1 yêu cầu http Ajax gửi đến và chúng ta có thể thấy nó ở phần network, có 1 phần có type là xhr và Initiator là ajaxRequestInterceptor... và nếu chúng ta kiểu tra tab header ở đây, chúng ta có thể thấy 1 get request được gửi tới academy.net/search-result?search... sau đó 1 phần của chuỗi truy vấn chúng ta thấy cụm từ tìm kiếm của chúng ta. Xem response thấy phản hồi là 1 đối tượng json, vì vậy chúng ta có khóa đầu tiên là reuslts sau đó là mảng trống và vì chúng ta không có kết quả nào khớp , chúng ta có khóa thứ 2 thứ phản ánh gửi lại cụm từ tìm kiếm cho chúng ta, nên chúng ta có khóa searchTerm như 1 phần của đối tượng JSON này và nó cho chúng ta biết cụm từ tìm kiếm của bạn,và rõ ràng nó sẽ được lấy và phản ánh trên trang. Nếu chúng ta tìm hiểu kĩ trong mã JS , chúng ta có thể thấy điều đó, vì vậy hãy nhớ rằng chúng ta có phản hồi JSON được lưu trữ trong this.responseText mà JSON đã được liên kết với biến var searchResultsObj và được chuyển tới displaySearchResults để hiển thị và hàm này làm gì?, cơ bản là nó đi qua DOM và hiển thị tất cả kết quả tìm kiếm của chúng ta vào trang nhưng hiện tại chúng ta không có kết quả nên ko quá quan tâm tới điều đó vì lỗ hổng thực sự xảy ra trước khi tất cả thông tin đó được hiển thị cho DOM. Hãy xem Ajax đó, HTTP request được gửi tới điểm cuối kết quả tìm kiếm trả về đối tượng JSON, nên chúng ta có thể yêu cầu HTTP request đó ở đây và chúng ta có thể thấy phản hồi JSON, chúng ta có 1 mảng trống cho results vì cụm từ của chúng ta không trả về bất kì kết quả nào và chúng ta có từ tìm kiếm của mình trong searchTerm. Bây giờ chúng ta sẽ tiếp tục và thấy rằng có thể thoát khỏi chuỗi này và thêm alert() hoặc chúng ta có thể trừ đi trong chuỗi này, trong trường hợp này chúng ta thử nghiệm đầu vào đó, chúng ta có thể nhấp chuột phải và chọn gửi tới repeater, cố gắng phá vỡ chuỗi bằng cách thêm dấu " ở cuối và gì đó như - alert() và lí do tại sao chúng ta lại thích sử dụng dấu - thay vì +, đơn giản vì + thường được mã hóa URL trong khi dấu - thì không. Như có thể thấy là ta thất bại trong việc thoát khỏi chuỗi và đó là do phản hồi JSON tự động thoát dấu " của ta (\") , đây là tính năng tiêu chuẩn của JS. Tuy nhiên, dấu ngoặc kép ngược cũng là 1 ký tự đặc biệt có thể thoát, vì vậy nếu chúng ta gửi \" .... có thể thấy ta đã thoát được ra khỏi chuỗi, ta có được: "searchTerm":"tmt\\"-alert(1)". Vấn đề là chúng ta không có 1 đối tượng JS hợp lệ ở giai đoạn này vì chúng ta có dấu ngoặc kép thừa ở cuối, chúng ta có thể comment nó và cách sử dụng comment là // nhưng chúng ta cần kết thúc đối tượng JS trước nên nó sẽ là \"-alert()}// , ta có thể sử dụng nó để hoàn thành lab. 

hàm eval() sẽ nhận tham số là 1 chuỗi ví dụ như '1+1' và thực thi nó như 1 mã JS, ở đây chuỗi ta có là 'var searchResultsObj = ...' --> nó sẽ thực thi như là 1 đoạn mã JS cố gắng tạo 1 biến, và eval() sẽ cố gắng thực hiện những mã js trong chuỗi này, vậy nên nếu ta đặt nhiều hơn 1 lệnh ở đây, tức là vừa tạo biến, vừa cố gắng sử dụng alert() thì eval sẽ thực hiện cả 2 và ta có thể xss. 

Nhưng câu hỏi đặt ra là vì sao nó hoạt động ??? 
vì chắc chắn thường chúng ta không thể comment mọi thứ về 1 đối tượng JS nhưng vấn đề là ở đây nó không phải là một đối tượng JS thuần túy mà nó thực sự được xây dựng từ 1 chuỗi và điều này là nơi chúng ta lặp lại hàm eval() gây ra vấn đề cho chúng ta. Cách tốt nhất là tạo 1 lab mới

Mục đích của lab mới là tạo ra 1 trang web, có mục đích là gửi yêu cầu tới file data.json, nếu ban đầu mã JS có dạng: 
        if(this.readyState==4 && this.status == 200){
            console.log(this.response);
            let myObj = this.response;
        } 
vậy bây giờ this.response là gì? là 1 đối tượng JSON, không nó là 1 chuỗi, đôi khi ta quên điều này vì trong JS frameworks và Promises chuyển phản hồi JSON vào 1 đối tượng cho ta trong khi điều đó không xảy ra với xhr request này, đây thực sự là 1 chuỗi, ta có thể chứng minh điều này bằng cách thêm console.log(typeof.this.response); nếu để myObj = JSON.parse(this.response); --> lúc này nó là kiểu Object , lúc này có thể thêm document.getElementById('page').innerText = myObj.infomation; để hiển thị kết quả lên trang. Vì mục đích của ta là thực hiện được alert nên ta sẽ sửa data.json thành "tmt"-alert() ta sẽ thấy alert() màu đỏ vì nó là cú pháp không hợp lệ với 1 đối tượng JSON. Vì đối tượng trong JS và đối tượng trong JSON khác nhau, trong JSON giá trị phải là 1 trong các kiểu đối tượng như chuỗi, số, đối tượng, mảng, bool, null; còn trong js nó là tất cả những kiểu trên và có thể cộng với những phần mở rộng js hợp lệ như: 1 hàm, 1 date, undefined. đó là lí do vì sao khi ta sửa data, hàm JSON.parse sẽ sinh ra lỗi vì nó không phải 1 đối tượng JSON hợp lệ, vì vậy khi ta sử dụng eval ('let myObj = ' + this.reponse); ở đây thì this.response lúc này là JSON nhưng là 1 chuỗi nên có thể được nối, điều này thực sự truyền thẳng vào 1 đối tượng JS lấy 1 chuỗi và đang sử dụng nó để tạo đối tượng JS, nó hoàn toàn bỏ qua JSON.parse và vì vậy khi thêm hàm alert() vào nó hợp lệ và eval thực thi hàm đó. 1 trong những điểm thú vị của phòng này là ban đầu ta nghĩ tấn công xss xảy ra khi thông tin hiển thị cho DOM, trong khi thực tế hàm eval đã kích hoạt cuộc tấn công, thực tế việc hiển thị tới DOM thậm chí không hoạt động trừ khi ta sử dụng var thay vì let và kết quả hiển thị ra là NaN, lí do có NaN liên quan đến kiểu gõ động trong JS, nó đang cố gắng giả định rằng phần giá trị của khóa trong data là 1 số nguyên trong khi thực tế không phải vậy.
