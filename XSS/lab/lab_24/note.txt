XSS - Exploiting cross-site scripting to steal cookies

End Goal:  To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.

Analystic
---------
Vì không có bản pro --> cuộc tấn công trở nên phức tạp hơn. Đây không chỉ là tấn công xss để steal cookie và mạo danh nữa. Nếu chúng ta muốn giải quyết, chúng ta sẽ cần thực hiện 1 cuộc tấn công giả mạo yêu cầu trên nhiều trang web, nên thứ tự hoạt động ở đây, chúng ta sẽ tấn công xss trên nhiều trang web sẽ dẫn đến giả mạo yêu cầu trên nhiều trang web, sau đó sẽ thao túng 1 yêu cầu bị đánh cắp cookie cho một cuộc tấn công chiếm quyền điều khiển phiên hoạt động có 3 thành phần khác nhau để giải quyết lab mà không cần sử dụng bản pro. 
Trên thực tế thay vì bật alert, ta sẽ tạo 1 số loại yêu cầu HTTP request nên ít nhất ý tưởng là HTTP request có thể được tạo bằng cách sử dụng JS tìm nạp Trình duyệt của người dùng bị thao túng để gửi yêu cầu HTTP đến điểm cuối thuộc sở hữu của kẻ tấn công và tất nhiên cùng với yêu cầu đó, thường sẽ có thông tin phiên được gửi như cookie, vì vậy tất cả những gì phải làm là kiểm tra các yêu cầu HTTP tới endpoint đó. Họ có thể lấy cookie của người dùng sau đó sử dụng để chiếm quyền điều khiển phiên của nạn nhân. 
Khi truy cập web, ta có thể xem từng bài post và chúng có ID riêng và chúng ta có thể comment vào post. Ý tưởng là trường comment dễ bị tấn công bởi xss. Trên thực tế, ta chỉ cần sử dụng thẻ script trong phần bình luận này không có bất kỳ vấn đề gì, vì vậy để chứng minh khái niệm, hãy đưa 1 số thẻ tập lệnh vào phần bình luận chúng ta phải điền. Chúng ta cần sử dụng burp để theo dõi yêu cầu HTTP này vì chúng ta sẽ quan tâm đến cách hình thành chính xác post request để tạo 1 bài comment. 
Chúng ta sẽ viết JS gây ra lỗi nạn nhân đăng phiên cookie của họ dưới dạng comment trên Blog. Giờ có thể nhớ trong hướng dẫn có nói rằng giải pháp thay thế kém tinh tế hơn đó là vì nếu chúng ta yêu cầu nạn nhân đăng cookie của họ dưới dạng comment trên Blog thì có nghĩa là bất kỳ khách truy cập nào vào cũng sẽ xem phiên cookie của nạn nhân nên họ sẽ biết rằng 1 cuộc tấn công đã xảy ra, nếu chúng ta so sánh việc nạn nhân gửi HTTP tới điểm cuối thì những khách truy cập khác sẽ không thể thấy phiên cookie đó và sẽ có ít bằng chứng hơn cho thấy 1 cuộc tấn công đã diễn ra nhưng thách thức thực sự ở đây là thực sự chỉ giải quyết lab mà không cần sử dụng pro.
Giờ hãy kiểm tra HTTP request đã được sử dụng để đăng comment, ta có thể thấy điểm cuối của bài đăng là /post/comment, chúng ta cũng có thể thấy session cookie của chúng ta được gửi cùng với yêu cầu. Hãy nhớ rằng đây là thứ chúng ta muốn đánh cắp. Tin tốt là việc truy cập cookie đó rất đơn giản khi chúng ta có thể chạy JS tùy ý trên trình duyệt của nạn nhân, chỉ cần vào console gõ document.cookie; và chúng ta nhận được session id. Xem kĩ hơn bên dưới ta sẽ thấy có 1 số tham số cần được gửi cùng bài đăng như csrf, đây là mã thông báo giả mạo yêu cầu trên nhiều trang web, nó đảm bảo rằng yêu cầu bắt nguồn từ cùng 1 vị trí với nơi tạo biểu mẫu, chúng ta sẽ xem xét điều này, hãy xem xét các tham số khác và chúng ta có postId và comment rồi còn name, email, website. những trường này đều dễ để cung cấp các giá trị tùy ý khi chúng ta yêu cầu nạn nhân post comment.Phần khó hơn là mã csrf vì nếu không có , chúng ta sẽ không thể đăng comment thay người dùng. Vì vậy hãy xem nhanh cách hoạt động của các mã csrf. Chúng ta sẽ xem xét page Source , cuối trang có 1 biểu mẫu và thông rằng có 1 trường tự động được thêm vào biểu mẫu này nên loại đầu vào được ẩn để người dùng không nhìn thấy thông tin này trên chính trang đó nhưng họ sẽ không biết mã csrf này là gì trừ khi họ là người hiển thị biểu mẫu để bắt đầu. thực sự đó là điều ngăn cản kẻ tấn công gửi 1 bài đăng thay mặt người dùng bằng cách gửi tất cả dữ liệu này đến điểm cuối của post comment vì họ sẽ không biết giá trị mã thông báo crsf là gì trừ khi họ là người đã truy cập vào form để bắt đầu vấn đề là vì chúng ta có thể chạy JS tùy ý nên khá dễ dàng để truy cập giá trị của mã csrf , hiện tại có nhiều cách khác nhau để truy cập mã này bằng JS nên dễ nhất là chỉ xem thuộc tính name ở đó bởi vì rất có thể đây là thành phần duy nhất trên trang có thuộc tính có giá trị là csrf. 
Quay lại trang, chúng ta có thể tham chiều document.getElementsByName('csrf')[0].value để lấy mã và ta có thể thực hiện điều này trong trình duyệt của nạn nhân nên chúng ta sẽ viết nó trong 1 tập lệnh js. Chúng ta sẽ tự viết nó trong ngữ cảnh HTML nên chúng ta sẽ cần các thẻ script nhưng bây giờ chúng ta sẽ sử dụng JS theo cách chính xác việc sử dụng JS để đăng biểu mẫu là sử dụng lớp dữ liệu biểu mẫu, vì vậy hãy khởi tạo lớp mới, var data = new FormData(); , thêm các cặp khóa giá trị khác nhau mà chúng ta muốn đăng như 1 phần của biểu mẫu nên chúng ta có thể chỉ cần sử dụng data.append('tên trường'):
<script>
windom.addEventListener('DOMContentLoaded',function(){
var token = document.getElementsByName('csrf')[0].value;
var data = new FormData();
data.append('csrf',token);
data.append('postId', 8);
data.append('comment',document.cookie) chúng ta muốn nạn nhân đăng cookie của họ nên sử dụng document.cookie
data.append('name','victim');
data.append('email','victim@gmail.com');
data.append('website','https://google.com');
Bây giờ chúng ta có thể sử dụng fetch API để tạo các HTTP request 
fetch('/post/comment',{
    method: 'POST',
    mode: 'no-cors',
    body: data
});
});
</script>

chúng ta đã biết điểm cuối sẽ đăng bình luận. Giờ chúng ta cần chỉ định bất kỳ dữ liệu nào nên chúng ta cần nói rằng phương thức sẽ là POST và chế độ yêu cầu, với điều này chúng ta thực sự sẽ không đặt nội dung vì lý do gì, và chúng ta chỉ có thể tham chiếu tới biến data mà chúng ta đã tạo, vì vậy chúng ta sẽ chưa có giá trị nào cho mã thông báo , vì vậy chúng ta cần tạo giá trị mã thông báo đó, ở trên cùng, ta sẽ đặt:
var token = document.getElementsByName('csrt')[0].value;
Giờ chúng ta đã truy cập vào mã csrf và truyền nó vào như 1 phnaf của biểu mẫu, giờ chúng ta vẫn còn chút vấn đề với điều này và nó liên quan đến cách các mục được hiển thị tới DOM vì vậy mã csrf được hiển thị cho DOM bằng JS và điều đó có nghĩa là nó sẽ không xuất hiện ngay khi tải trang ban đầu, vì vậy nếu JS này được gọi quá sớm thì mã csrf sẽ không tồn tại và rõ ràng là sẽ không được chuyển vào bất kỳ HTTP request nào tiếp theo của fetch API , vì vậy chúng ta cần trì hoãn việc thực thi JS này đến khi DOM được tải đầy đủ. chúng ta có thể sử dụng trình xử lý sự kiện : windom.addEventListener('') và sự kiện sắp diễn ra là lắng nghe nội dung DOM đã được tải và chúng ta muốn có 1 hàm gọi lại vì vậy đây là sự kiện sẽ bắt đầu sau khi DOM được tải nên chúng ta đợi DOM tải hoàn toàn, điều đó có nghĩa là csrf sẽ được đính kèm vào form sau đó chúng ta có thể truy cập bằng js, nạn nhân sẽ đăng comment trên blog và ý tưởng là điều này được lab mô phỏng nên khi chúng ta gửi cuộc tấn công, lab sẽ giả vờ nạn nhân truy cập trang web cụ thể đó và nếu có là bất kỳ cuộc tấn công xss nào, nó sẽ được thực thi và tất nhiên bao gồm mọi thông tin liên kết , trước khi dán mọi thứ vào. Chúng ta cần thêm 1 số thẻ <script> , chúng ta có thẻ thay đổi giá trị id của post trước khi chúng ta tấn công. Sau đó ta quay lại lab, vào 1 bài post bất kì, copy tập lệnh script và dán vào phần comment, điền toàn bộ các trường còn lại và thực hiện post comment, sau đó quay trở lại post ta thấy nhận được nội dung: 
secret=w8Bk1RGeCGrW6xvRyViPCyGMmCqpvJGr; 
session=YzWF6digPiEHpfryk8hVuuKz3numtE0N
chúng ta có thể thấy nạn nhân đã truy cập trang và giá trị của document.cookie và chúng ta có thể thấy có 2 giá trị cookie đó mà chúng ta có secret, đó có thể là 1 loại mật khẩu nào đó mà chúng ta không biết. Rõ ràng là nó được băm nên 1 cuộc tấn công có thể xảy ra là thử và giải mã hàm băm cụ thể xem liệu chúng ta có nhận được thứ gì hữu ích không, chẳng hạn như mật khẩu nhưng chúng ta không thực sự cần điều đó vì chúng ta thực sự có session ID, đây là nơi chúng ta đến phần thứ 3 của cuộc tấn công: chiếm quyền điều khiển phiên. Vì vậy hãy sao chép cookie này nhưng hãy xem request tới tài /my-account, hãy gửi yêu cầu đó đến repeater và chúng ta sẽ thêm 1 cookie vì vậy ta sẽ nói: Cookie: session=YzWF6digPiEHpfryk8hVuuKz3numtE0N
gửi nó đi và đến phần hiển thị phản hồi nhận thấy rằng My account tên người dùng là administrator nên rõ ràng là chúng ta có quyền truy cập vào tài khoản này 