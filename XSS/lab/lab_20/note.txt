XSS - Reflected XSS in a JavaScript URL with some characters blocked

End Goal: To solve the lab, perform a cross-site scripting attack that calls the alert function with the string 1337 contained somewhere in the alert message.

Analystic
---------
Đây là phòng lab rất khó, cần có 1 số kiến thức cơ bản để hiểu cách khai thác này và vì lý do đó, chúng ta sẽ bắt đầu với tải trọng và làm ngược lại, chúng ta có thể thấy tải trọng ở đây sau chuỗi truy vấn. Copy payload rồi gán vào phần Decode của Burp để có thể xem phiên bản khai thác được giải mã URL. 

https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'

Chúng ta có phần đầu tiên của chuỗi truy vấn: postId=5 là ID của bài đăng, sau đó chúng ta có ký hiệu và, sau đó chúng ta có 1 dấu ngoặc đơn và một dấu ngoặc nhọn đóng, điều này sẽ cho phép chúng ta đưa vào JS vì chúng ta ở trong dấu ngoặc nhọn. Sau đó chúng ta có dấu phẩy, lý do cho dấu phẩy là chúng ta đang cung cấp các đối số cho API tìm nạp nên chúng ta đang cung cấp 1 danh sách các đối số được phân tách bằng dấu phẩy. Trên thực tế, chúng ta đang cung cấp nhiều hơn những gì chúng ta dự kiến, chúng ta sẽ xử lý điều đó sau. Và chúng ta có ,x=x thực ra chúng ta đang khai báo 1 hàm mũi tên trong JS, chúng ta đang liên kết nó với x; thông thường chúng ta sẽ thấy các dấu ngoặc thông thường được sử dụng như 1 phần của khai báo hàm mũi tên trong JS nhưng chúng thực sự sẽ bị chặn bởi trang web, nó chuyển ra ngoài, bạn không cần sử dụng dấu ngoặc trái phải nên chúng ta chỉ cần có x = x=>, sau đó chúng ta có thể mở khối mã bên trong khối mã mà chúng ta sử dụng câu lệnh throw mà thực tế chúng ta đang truyền 2 giá trị, 1 giá trị cho onerror=alert() và sau đó chúng ta cũng chuyển giá trị 1337 thông báo rằng nó được chuyển dưới dạng thông báo, danh sách được phân tách bằng dấu ,. Thông tin này thêm về điều này 1 lát sau thông báo rằng chúng ta cũng có 1 close comment characters ở giữa throw và onerror=alert(), lý do là chúng ta không thể sử dụng khoảng trắng nên đây là 1 cách giả mạo nhận xét đóng mở khoảng trắng trong khi đóng khối mã của chúng ta, sau đó sử dụng dấu phẩy để giờ chúng ta chuyển 1 đối số khác cho API tìm nạp là: toString=x , sau đó chúng ta có 1: window+' , sau đó chúng ta có đối số cuối cùng mở ra 1 dấu ngoặc nhọn mới chúng ta có giá trị x dấu 2 chấm và sau đó 1 dấu ngoặc '. Phần cuối cùng của tải trọng ở đây thực sự chỉ là để dọn dẹp JS nên chúng ta không gặp lỗi. Chúng ta sẽ chỉa phần này thành 2 phần, vì vậy phần cuối cùng ở đây thực sự liên quan đến việc tiêm chính nó để đảm bảo việc khai thác được thực hiện 1 cách rõ ràng. Và phần đầu của tải trọng này, trích dẫn đơn và dấu ngoặc nhọn đóng liên quan đến chính việc tiêm, trước hết chúng ta sẽ tập trung vào logic khai thác, đó là mọi thứ bắt đầu từ x=x=> cho đến window+''. Để phân tích điều này, chúng ta sẽ tạo 1 tài liệu HTML trống:
<h1>My Awesome Page</h1>

<script>
    
</script>
Trước hết hãy bắt đầu với cầu lệnh throw, chúng ta cung cấp cho nó 1 giá trị mà sau đó nó sử dụng như 1 phần của kết quả lỗi, vì vậy, ví dụ: nếu chúng ta throw 1337; thì chúng ta sẽ đưa ra một lỗi. Để có giá trị 1337. Sau khi mở trang web, thông báo trình duyệt trong Console, chúng ta có thông báo: Uncaught 1337; bây giờ câu hỏi tiếp theo là điều gì sẽ xảy ra nếu chúng ta cung cấp 1 danh sách được phân tách bằng dấu , và dấu phẩy này là một loại toán tử và tất cả những gì nó làm là trả về giá trị cuối cùng hoặc biểu thức cuối cùng như một phần của câu lệnh. Nên ở đây, mọi thứ cùng nhau đây là một câu lệnh (throw 1337, 1338;) nhưng nó bao gồm các biểu thức riêng lẻ trả về các giá trị cụ thể trong trường hợp này nó sẽ trả về giá trị cuối cùng trong danh sách được phân tách bằng dấu phẩy nên nếu chúng ta đưa ra 1337 và 1338 vào danh sách được phân tách bằng dấu phẩy thì lỗi sẽ đưa ra 1338. Chúng ta lại quay lại với web của ta, hãy làm mới trang và ta có thể thấy: Uncaught 1338 mà không có bất kì tham chiếu nào đến 1337. Về cơ bản chúng ta có thể truyền bao nhiêu giá trị tùy thích như 1 phần của danh sách được phân tách bằng dấu phẩy này, chỉ có giá trị cuối cùng sẽ được trả về nhưng chúng ta có thể sử dụng các mục khác trong danh sách được phân tách bằng dấu phẩy để thực hiện các chức năng khác nhau. Ví dụ, hãy tạo 1 biến: let myVar = 1; chúng ta có thể sử dụng myVar làm giá trị được throw ra (throw 1377,myVar), nếu làm mới trang ta sẽ nhận được Uncaught 1 do 1 phần của lỗi đó nhưng thực tế chúng ta có thể thay đổi giá trị của myVar trong giá trị đầu tiên mà chúng ta cung cấp để throw, nói đơn giản là: throw myVar=1337, myVar; lúc này nếu làm mới trang ta sẽ nhận được Uncaught 1337.
Vì vậy hãy quay lại với payload của chúng ta: https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'
chúng ta đưa ra 1 danh sách được phân tách bằng dấu , với 2 giá trị mà chúng ta có là 1337 là giá trị thực sự sẽ được đưa ra và chúng ta có 1 phép gán làm giá trị đầu tiên mà phép gán có onerror=alert(). Vì vậy câu hỏi đặt ra là tiếp theo chức năng của onerror = alert() là gì. Trước hết là onerror, đó thực sự là trình xử lý lỗi JS và chúng ta biết alert() được tích hợp trong hàm JS gây ra cửa sổ bật lên trong cửa sổ trình duyệt với 1 thông báo được chỉ định, nói cách khác, chúng ta đang ghi đè 1 phần hành vi mặc định của JS do onerror đã có chức năng rất cụ thể của riêng nó và chúng ta đang ghi đè lên điều đó bằng cách nói rằng nó phải có chức năng tương tự như hàm alert() của JS nên bất cứ khi nào trình xử lý sự kiện có lỗi được kích hoạt, chúng ta thực sự sẽ làm gì đó với chức năng alert() trong JS thay vì tất nhiên khi nào trình xử lý sự kiện có lỗi sẽ được kích hoạt tốt thì chắc chắn nó sẽ được kích hoạt khi chúng ta sử dụng tính năng throw vì chúng ta biết throw khi có lỗi, thay vì lấy đầu ra của bảng điều khiển tiêu chuẩn của chúng ta Uncaught và sau đó là giá trị myVar, nó chỉ đơn giản chuyển giá trị cuối cùng này trong danh sách được ngăn cách bằng dấu phẩy sang hàm cảnh báo alert(), vì vậy hãy chứng minh rằng chúng ta sẽ loại bỏ myVar và thay vào là 1337 (throw onerror=alert,1337). Vì vậy tất cả những gì chúng ta có ở đây là 1 câu lệnh throw đơn giản mà chúng ta đặt onerror handle = alert, sau đó chúng ta sẽ vượt qua 1337 để throw trình kích hoạt nào có lỗi 1337, sau đó sẽ được chuyển tới hàm alert. Hày làm mới trang, lưu ý rằng chúng ta không nhận được bất kỳ Uncaught nào trong Console nên chúng ta không nhận được hành vi xử lý lỗi mặc định của js, chúng ta thực sự có ngoại lệ Uncaught 1337 được chuyển đến chính hàm alert. Bây giờ quay lại phần payload, lưu ý rằng tất cả logic mà chúng ta vừa xem xét thực sự nằm trong một khối mã vì vậy hãy xử lý x=x 1 phần của tải trọng này; hãy quay lại với trang của chúng ta, bây giờ tất cả là 1 hàm mũi tên trong js đầy đủ, chúng ta sẽ thấy nó được viết như thế này: 
let x = (x) => {
    throw onerror=alert, 1337;
}
Giờ đây nó là 1 hàm lỗi, giả sử rằng hàm của chúng ta không sử dụng các đối số và chúng ta có thể thấy trong trường hợp này rõ ràng là nó không sử dụng x ở bất kì đâu trong hàm mà chúng ta thường liên kết các hàm được viết với cú pháp này let x trong đó x = tên của hàm đằng sau đó chúng ta có phạm vi hàm mở và đóng sau đó chúng ta có chính mũi tên sau đó chúng ta có khối mã: 
let x = () => {
    throw onerror=alert, 1337;
}
 vấn đề chúng ta gặp phải là các dấu ngoặc này sẽ bị chính trang web của chúng ta chặn và những gì chúng ta còn lại không có ý nghĩa gì nhưng bằng cách cung cấp 1 đối số ở đây JS thấy rõ ràng đây vẫn là một hàm mũi tên và về mặt cú pháp nó tương đương với điều tương tự nhưng có dấu ngoặc xung quanh:
 let x = x => {
    throw onerror=alert, 1337;
}
Giá trị của bản thân đối số thực sự không quá quan trọng, điều quan trọng duy nhất trong bối cảnh khai thác là chúng ta không thể có space nên hiện tại chúng ta có nhiều không gian như chúng ta muốn nhưng vì điều này cần phải được chứa bên trong URL, các khoảng trắng sẽ phá vỡ hoạt động khai thác trong trường hợp này nhưng những gì chúng ta thấy trên màn hình hiện tại về mặt cú pháp tương đương ít nhiều với những gì chúng ta đã thấy trong tải trọng, vì vậy bây giờ khi làm mới trang chúng ta thấy sẽ không nhận được cảnh báo nào xuất hiện đó là do logic nằm bên trong 1 hàm nên chỉ khi chúng ta gọi 1 hàm chẳng hạn: x();, sau đó nó sẽ bật lên cảnh báo trên trang. 
<h1>My Awesome Page</h1>

<script>
    let x = x => {
        throw onerror=alert,1337;
    }
    x();
</script>

Phần tiếp theo của tải trọng là toString=x, rõ ràng toString là 1 hàm nhằm chuyển đổi dữ liệu từ 1 kiểu khác về kiểu string như lúc này nó bị ghi đè bởi mà x đang có giá trị là 1 hàm arrow có chức năng throw --> lúc này hàm toString đã bị ghi đè chức năng. Kế tiếp trong payload có window+'', có thể thấy ở đây nó đang cố gắng thực hiện nối chuỗi nhưng rõ ràng là window không phải là 1 chuỗi, chính vì vậy JS sẽ thực hiện gọi hàm toString để biến window thành chuỗi và nối nó với 1 chuỗi rỗng ''. Đây chính là lúc chức năng của hàm toString bị ghi đè kích hoạt và ta có thể kích hoạt alert trên trang của mình. 
Tuy nhiên đó mới chỉ là 1 phần của payload, để hiểu sâu hơn về nó, ta sẽ đi vào bài blog của lab, tìm kiếm từ khóa postId, ta có kết quả như sau:
<a href="javascript:fetch('/analytics', {method:'post',body:'/post%3fpostId%3d5'}).finally(_ => window.location = '/')">Back to Blog</a>
ta thấy ở đây nó đang thực hiện 1 hàm js bên trong thuộc tính href của thẻ a, trong khi đó tham số được truyền vào thẻ chính là lấy từ các tham số từ URL --> ta có thể lợi dụng điều này để thực hiện tấn công XSS ở đây. Tại đây họ đang sử dụng 1 hàm fetch(), đây là 1 hàm nạp API của JS, nó dùng để gửi các yêu cầu HTTP tới các URL khác nhau và thao tác dữ liệu phản hồi. Nó được thiết kế để lấy 1 số tham số ví dụ: tham số đầu tiên ở đây chính là URL nên chúng ta có thể thấy yêu cầu HTTP đang được gửi đi để chuyển tiếp tới /analytics, sau đó có dấu phẩy để cho biết phần cuối của 1 đối số sau đó chúng ta chuyển qua đối số thứ 2 nhằm cung cấp dữ liệu liên quan đến HTTP request đó là 1 tùy chọn cấu hình, bạn có thể thấy một số ví dụ về cách sử dụng điều này ở đây chúng ta có POST method --> nó là Post request, sau đó chúng ta có phần body tức là nội dung của request và trong đó chứa giá trị được đưa vào như 1 phần của nội dung bài đăng; chúng ta có thể thấy ID bài đăng được URL mã hóa ở đây. Ngữ cảnh ở đây là chúng ta đang ở trong 1 đối tượng tùy chọn cấu hình của phương thức fetch và ý tưởng là chúng ta sẽ thoát ra khỏi tùy chọn cấu hình đó và bắt đầu cung cấp các đối số bổ sung cho fetch API, hiện tại fetch có lẽ chỉ lấy 2 đối số nhưng ý tưởng là ta sẽ cung cấp nhiều đối số hơn API tìm nạp 
Về cách các đối số hoạt động ta lại có 1 ví dụ, ta có 1 hàm như sau:
function myFunc(a,b){
    return a + b;
}
ta có thể thấy hàm này chỉ nhận 2 đối số sau đó trả về kết quả của phép cộng giữa 2 đối số, câu hỏi đặt ra là nếu ta truyền vào nhiều hơn 2 đối số, JS sẽ hiển thị lỗi hay chọn bất kì 2 trong số nhiều đối số ta đưa vào? Sau khi đặt hàm này vào trang ta có thể thấy hàm vẫn chỉ thực hiện lấy 2 đối số đầu tiên mà k hiển thị bất kì lỗi nào. Kế tiếp ta giả sử có đoạn code như sau:
    let myVar = 1;
function myFunc(a,b){
    return a + b;
}
console.log(myFunc(1,2,3,4,5,6,7));
console.log(myVar);
Lúc này nếu đặt vào trang web, ta có thể thấy trong phần console chỉ hiển thị 3 và 1 tức là dù có bao nhiêu tham số được truyền vào hàm vẫn hoạt động. Vậy nếu ta thử thay đổi giá trị của biến thì sao?, ta có đoạn code sau:
    let myVar = 1;
function myFunc(a,b){
    return a + b;
}
console.log(myFunc(1,2,3,4,myVar=10,6,7));
console.log(myVar);
Lúc này console hiển thị 3 và 10, tức là giá trị của biến myVar đã bị thay đổi. Vì vậy với ý tưởng là fetch API tìm nạp thường là chúng ta sẽ cung cấp 2 đối số nhưng miễn là chúng ta đưa vào API tìm nạp, chúng ta có thể cung cấp nhiều hơn những đối số cần thiết, trong đó có cả những đối số có thể là những câu lệnh dùng để thay đổi code, điển hình là những câu lệnh dùng để thay đổi giá trị. Vì vậy quay lại với payload, trước hết chúng ta có ký tự và, vì vậy theo thuật ngữ của trình duyệt cho biết cặp giá trị khóa tiếp theo như một phần của chuỗi truy vấn, nếu chúng ta thử đưa trực tiếp ' thì nó thực sự sẽ phá vỡ trang web vì 1 phần của trang hoặc 1 phần của truy vấn được gửi đến backend chỉ đơn giản là tìm kiếm 1 số nên có vẻ như dấu và cho phép trang tiếp tục hoạt động nhưng chính cuộc tấn công tiêm nhiễm bắt đầu ở ' nên ' sẽ đóng chuỗi rằng chúng tôi là 1 phần của dấu ngoặc nhọn bên phải đóng cấu hình cẩu fetch API , sau đó chúng ta có thể bắt đầu thêm tham số hoặc đối số vào fetch API. Vì vậy đây là lí do tại sao chúng ta có danh sách được phân cách bằng dấu ,. Nếu tự hỏi tại sao lại k thể sử dụng throw trực tiếp thì vì throw là 1 câu lệnh, nó không có giá trị trả về do đó không thể được chuyển làm đối số cho fetch API, trong khi chúng ta xác định 1 hàm có giá trị trả về. Cuối cùng chúng ta có 1 đối số cuối cùng và mục đích duy nhất của đối số này là kết thúc cuộc tấn công 1 cách nhẹ nhàng vì hiện tại chúng ta vẫn sẽ có 1 dấu ' ở cuối đóng và dấu ngoặc nhọn đóng khung bên phải --> mã JS sẽ không bị lỗi. 